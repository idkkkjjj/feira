<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Visualizador de Bordados com ZIP/RAR</title>
<style>
body { font-family: Arial, sans-serif; text-align: center; padding: 20px; }
canvas { border: 1px solid #000; margin-top: 20px; }
#info { margin-top: 20px; text-align: left; display: inline-block; }
button { margin-top: 10px; padding: 10px 20px; cursor: pointer; }
#status { margin-top: 15px; font-weight: bold; }
.archive-file { cursor: pointer; color: blue; text-decoration: underline; }
.archive-file:hover { color: darkblue; }
.ok { color: green; }
.error { color: red; }
.loading { color: orange; }
</style>
</head>
<body>
<h1>Visualizador de Bordados</h1>

<input type="file" id="fileInput" accept=".pes,.dst,.exp,.jef,.vp3,.hus,.pcs,.pcm,.sew,.shv,.vip,.xxx,.pec,.zip,.rar" />
<br>
<button id="confirmBtn">Confirmar Arquivo</button>

<canvas id="canvas" width="500" height="500"></canvas>

<div id="status">‚è≥ Aguardando sele√ß√£o de arquivo...</div>
<div id="info"></div>
<div id="archiveList"></div>

<script src="https://cdn.jsdelivr.net/pyodide/v0.26.1/full/pyodide.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<script>
let pyodideReadyPromise = loadPyodide();
const fileInput = document.getElementById("fileInput");
const confirmBtn = document.getElementById("confirmBtn");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const infoDiv = document.getElementById("info");
const statusDiv = document.getElementById("status");
const archiveList = document.getElementById("archiveList");
const supportedFormats = ['pes','dst','exp','jef','vp3','hus','pcs','pcm','sew','shv','vip','xxx','pec'];

let selectedFile = null;
let zipFilesMap = {}; // caso seja ZIP, armazena arquivos

function setStatus(msg, cls="loading") {
  statusDiv.textContent = msg;
  statusDiv.className = cls;
}

fileInput.addEventListener("change", async (e) => {
  selectedFile = e.target.files[0];
  archiveList.innerHTML = "";
  setStatus("üìÇ Arquivo selecionado, clique em Confirmar.", "loading");

  if(!selectedFile) return;

  const name = selectedFile.name.toLowerCase();
  if(name.endsWith(".zip")) {
    const jszip = new JSZip();
    const zip = await jszip.loadAsync(selectedFile);
    zipFilesMap = {};
    const files = Object.keys(zip.files).filter(f => supportedFormats.includes(f.split('.').pop().toLowerCase()));
    if(files.length === 0) {
      archiveList.innerHTML = "‚ùå Nenhum arquivo suportado encontrado no ZIP.";
    } else {
      archiveList.innerHTML = "<h3>Arquivos suportados no ZIP:</h3><ul>" +
        files.map(f => `<li class="archive-file" data-file="${f}">${f}</li>`).join("") +
        "</ul>";
      files.forEach(f => zipFilesMap[f] = zip.files[f]);
    }
  } else if(name.endsWith(".rar")) {
    archiveList.innerHTML = "‚ö† RAR ainda n√£o implementado, mas √© poss√≠vel com unrar.js";
  }
});

archiveList.addEventListener("click", async (e) => {
  if(e.target.classList.contains("archive-file")) {
    const fileName = e.target.dataset.file;
    const fileData = await zipFilesMap[fileName].async("uint8array");
    selectedFile = new File([fileData], fileName);
    setStatus(`üìÇ Arquivo "${fileName}" selecionado do ZIP. Clique em Confirmar.`, "loading");
  }
});

confirmBtn.addEventListener("click", async () => {
  if (!selectedFile) {
    alert("Selecione um arquivo de bordado primeiro!");
    return;
  }

  try {
    setStatus("‚è≥ Carregando Pyodide...", "loading");
    const pyodide = await pyodideReadyPromise;

    setStatus("‚è≥ Instalando pyembroidery...", "loading");
    await pyodide.loadPackage("micropip");
    const micropip = pyodide.pyimport("micropip");
    await micropip.install("pyembroidery");

    setStatus("‚è≥ Lendo arquivo de bordado...", "loading");
    const arrayBuffer = await selectedFile.arrayBuffer();
    const bytes = new Uint8Array(arrayBuffer);
    pyodide.FS.writeFile("temp_input", bytes);

    const result = pyodide.runPython(`
from pyembroidery import read, write
import json

try:
    pattern = read("temp_input")
    pattern.write("temp.pes")  # converte pra PES

    min_x, min_y, max_x, max_y = pattern.bounds()
    width_mm = max_x - min_x
    height_mm = max_y - min_y
    num_colors = len(pattern.threadlist)
    num_stitches = len(pattern.stitches)

    stitches = [[float(x), float(y), int(cmd)] for x, y, cmd in pattern.stitches]
    colors = [{"name": t.description, "hex": "#{:06X}".format(t.color)} for t in pattern.threadlist]

    result = json.dumps({
        "width_mm": width_mm,
        "height_mm": height_mm,
        "num_colors": num_colors,
        "num_stitches": num_stitches,
        "stitches": stitches,
        "colors": colors
    })
except Exception as e:
    result = json.dumps({"error": str(e)})

result
    `);

    const data = JSON.parse(result);

    if (data.error) {
      setStatus("‚ùå Erro ao ler bordado: " + data.error, "error");
      return;