<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Visualizador de Bordados Inteligente</title>
<style>
body { font-family: Arial, sans-serif; text-align: center; padding: 20px; }
canvas { border: 1px solid #000; margin-top: 20px; }
#info, #archiveList { margin-top: 20px; text-align: left; display: inline-block; }
button { margin-top: 10px; padding: 10px 20px; cursor: pointer; }
#status { margin-top: 15px; font-weight: bold; }
.archive-file { cursor: pointer; color: blue; text-decoration: underline; }
.archive-file:hover { color: darkblue; }
.ok { color: green; }
.error { color: red; }
.loading { color: orange; }
</style>
</head>
<body>
<h1>Visualizador de Bordados Inteligente</h1>

<input type="file" id="fileInput" accept=".pes,.dst,.exp,.jef,.vp3,.hus,.pcs,.pcm,.sew,.shv,.vip,.xxx,.pec,.zip,.rar" />
<canvas id="canvas" width="500" height="500"></canvas>
<div id="status">‚è≥ Aguardando sele√ß√£o de arquivo...</div>
<div id="info"></div>
<div id="archiveList"></div>

<script src="https://cdn.jsdelivr.net/pyodide/v0.26.1/full/pyodide.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<script>
let pyodideReadyPromise = loadPyodide();
const fileInput = document.getElementById("fileInput");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const infoDiv = document.getElementById("info");
const statusDiv = document.getElementById("status");
const archiveList = document.getElementById("archiveList");

const supportedFormats = ['pes','dst','exp','jef','vp3','hus','pcs','pcm','sew','shv','vip','xxx','pec'];
let zipFilesMap = {};
let selectedFile = null;

function setStatus(msg, cls="loading") {
  statusDiv.textContent = msg;
  statusDiv.className = cls;
}

async function renderEmbroidery(file) {
  try {
    setStatus("‚è≥ Carregando Pyodide...", "loading");
    const pyodide = await pyodideReadyPromise;

    setStatus("‚è≥ Instalando pyembroidery...", "loading");
    await pyodide.loadPackage("micropip");
    const micropip = pyodide.pyimport("micropip");
    await micropip.install("pyembroidery");

    setStatus("‚è≥ Lendo arquivo de bordado...", "loading");
    const arrayBuffer = await file.arrayBuffer();
    const bytes = new Uint8Array(arrayBuffer);
    pyodide.FS.writeFile("temp_input", bytes);

    const result = pyodide.runPython(`
from pyembroidery import read, write
import json

try:
    pattern = read("temp_input")
    pattern.write("temp.pes")
    min_x, min_y, max_x, max_y = pattern.bounds()
    width_mm = max_x - min_x
    height_mm = max_y - min_y
    num_colors = len(pattern.threadlist)
    num_stitches = len(pattern.stitches)
    stitches = [[float(x), float(y), int(cmd)] for x, y, cmd in pattern.stitches]
    colors = [{"name": t.description, "hex": "#{:06X}".format(t.color)} for t in pattern.threadlist]
    result = json.dumps({
        "width_mm": width_mm,
        "height_mm": height_mm,
        "num_colors": num_colors,
        "num_stitches": num_stitches,
        "stitches": stitches,
        "colors": colors
    })
except Exception as e:
    result = json.dumps({"error": str(e)})
result
    `);

    const data = JSON.parse(result);

    if(data.error){
      setStatus("‚ùå Erro ao ler bordado: " + data.error, "error");
      return;
    }

    const xs = data.stitches.map(s => s[0]);
    const ys = data.stitches.map(s => s[1]);
    const minX = Math.min(...xs);
    const maxX = Math.max(...xs);
    const minY = Math.min(...ys);
    const maxY = Math.max(...ys);
    const width = maxX - minX;
    const height = maxY - minY;
    const scale = Math.min(canvas.width / width, canvas.height / height) * 0.9;

    ctx.clearRect(0,0,canvas.width,canvas.height);
    let colorIndex = 0;
    ctx.beginPath();
    ctx.strokeStyle = data.colors[colorIndex]?.hex || "black";

    for(let i=1;i<data.stitches.length;i++){
      const [x1,y1,cmd1] = data.stitches[i-1];
      const [x2,y2,cmd2] = data.stitches[i];

      if(cmd2 === 2){
        ctx.stroke();
        colorIndex++;
        ctx.beginPath();
        ctx.strokeStyle = data.colors[colorIndex]?.hex || "black";
        continue;
      }

      ctx.moveTo((x1-minX)*scale+20,(y1-minY)*scale+20);
      ctx.lineTo((x2-minX)*scale+20,(y2-minY)*scale+20);
    }
    ctx.stroke();

    setStatus("‚úÖ Sucesso: bordado carregado!", "ok");

    infoDiv.innerHTML = `
      <h2>Informa√ß√µes do Bordado</h2>
      <p><b>Largura:</b> ${(data.width_mm/10).toFixed(2)} cm</p>
      <p><b>Altura:</b> ${(data.height_mm/10).toFixed(2)} cm</p>
      <p><b>N√∫mero de cores:</b> ${data.num_colors}</p>
      <p><b>Total de pontos:</b> ${data.num_stitches}</p>
      <h3>Cores:</h3>
      <ul>
        ${data.colors.map(c=>`<li><span style="color:${c.hex}">‚¨§</span> ${c.name||"Cor"} (${c.hex})</li>`).join("")}
      </ul>
    `;
  } catch(err){
    setStatus("‚ùå Erro geral: " + err, "error");
  }
}

fileInput.addEventListener("change", async (e)=>{
  selectedFile = e.target.files[0];
  archiveList.innerHTML = "";
  infoDiv.innerHTML = "";
  if(!selectedFile) return;

  const name = selectedFile.name.toLowerCase();
  if(supportedFormats.includes(name.split('.').pop())){
    // arquivo compat√≠vel direto
    renderEmbroidery(selectedFile);
  } else if(name.endsWith(".zip")){
    setStatus("‚è≥ Extraindo ZIP...", "loading");
    const jszip = new JSZip();
    const zip = await jszip.loadAsync(selectedFile);
    zipFilesMap = {};
    const files = Object.keys(zip.files).filter(f=>supportedFormats.includes(f.split('.').pop().toLowerCase()));
    if(files.length===0){
      archiveList.innerHTML="‚ùå Nenhum arquivo suportado encontrado no ZIP.";
    }else{
      archiveList.innerHTML="<h3>Arquivos compat√≠veis no ZIP:</h3><ul>"+files.map(f=>`<li class="archive-file" data-file="${f}">${f}</li>`).join("")+"</ul>";
      files.forEach(f=>zipFilesMap[f]=zip.files[f]);
      setStatus("üìÇ Clique em um arquivo para abrir.", "loading");
    }
  } else if(name.endsWith(".rar")){
    archiveList.innerHTML="‚ö† RAR n√£o suportado ainda.";
    setStatus("‚ùå RAR n√£o suportado.", "error");
  } else{
    setStatus("‚ùå Arquivo n√£o suportado.", "error");
  }
});

archiveList.addEventListener("click", async (e)=>{
  if(e.target.classList.contains("archive-file")){
    const fileName = e.target.dataset.file;
    const fileData = await zipFilesMap[fileName].async("uint8array");
    const fileObj = new File([fileData], fileName);
    renderEmbroidery(fileObj);
  }
});
</script>
</body>
</html>