<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Visualizador de Bordados</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; padding: 20px; }
    canvas { border: 1px solid #000; margin-top: 20px; }
    #info { margin-top: 20px; text-align: left; display: inline-block; }
    button { margin-top: 10px; padding: 10px 20px; cursor: pointer; }
    #status { margin-top: 15px; font-weight: bold; }
    .ok { color: green; }
    .error { color: red; }
    .loading { color: orange; }
  </style>
</head>
<body>
  <h1>Visualizador de Bordados</h1>

  <input type="file" id="fileInput" accept=".pes,.dst,.exp,.jef,.vp3,.hus,.pcs,.pcm,.sew,.shv,.vip,.xxx,.pec" />
  <br>
  <button id="confirmBtn">Confirmar Arquivo</button>

  <br>
  <canvas id="canvas" width="500" height="500"></canvas>

  <div id="status">‚è≥ Aguardando sele√ß√£o de arquivo...</div>
  <div id="info"></div>

  <script src="https://cdn.jsdelivr.net/pyodide/v0.26.1/full/pyodide.js"></script>
  <script>
    let pyodideReadyPromise = loadPyodide();
    const fileInput = document.getElementById("fileInput");
    const confirmBtn = document.getElementById("confirmBtn");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const infoDiv = document.getElementById("info");
    const statusDiv = document.getElementById("status");
    let selectedFile = null;

    function setStatus(msg, cls="loading") {
      statusDiv.textContent = msg;
      statusDiv.className = cls;
    }

    fileInput.addEventListener("change", (e) => {
      selectedFile = e.target.files[0];
      setStatus("üìÇ Arquivo selecionado, clique em Confirmar.", "loading");
    });

    confirmBtn.addEventListener("click", async () => {
      if (!selectedFile) {
        alert("Selecione um arquivo de bordado primeiro!");
        return;
      }

      try {
        setStatus("‚è≥ Carregando Pyodide...", "loading");
        const pyodide = await pyodideReadyPromise;

        setStatus("‚è≥ Instalando pyembroidery...", "loading");
        await pyodide.loadPackage("micropip");
        const micropip = pyodide.pyimport("micropip");
        await micropip.install("pyembroidery");

        setStatus("‚è≥ Lendo arquivo de bordado...", "loading");
        const arrayBuffer = await selectedFile.arrayBuffer();
        const bytes = new Uint8Array(arrayBuffer);
        pyodide.FS.writeFile("temp_input", bytes);

        const result = pyodide.runPython(`
from pyembroidery import read, write
import json

try:
    # L√™ qualquer formato suportado
    pattern = read("temp_input")

    # Salva como PES tempor√°rio
    pattern.write("temp.pes")

    # Obt√©m bounds e informa√ß√µes
    min_x, min_y, max_x, max_y = pattern.bounds()
    width_mm = max_x - min_x
    height_mm = max_y - min_y
    num_colors = len(pattern.threadlist)
    num_stitches = len(pattern.stitches)

    stitches = [[float(x), float(y), int(cmd)] for x, y, cmd in pattern.stitches]
    colors = [{"name": t.description, "hex": "#{:06X}".format(t.color)} for t in pattern.threadlist]

    result = json.dumps({
        "width_mm": width_mm,
        "height_mm": height_mm,
        "num_colors": num_colors,
        "num_stitches": num_stitches,
        "stitches": stitches,
        "colors": colors
    })
except Exception as e:
    result = json.dumps({"error": str(e)})

result
        `);

        const data = JSON.parse(result);

        if (data.error) {
          setStatus("‚ùå Erro ao ler bordado: " + data.error, "error");
          return;
        }

        // Normaliza coordenadas
        const xs = data.stitches.map(s => s[0]);
        const ys = data.stitches.map(s => s[1]);
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);
        const width = maxX - minX;
        const height = maxY - minY;
        const scale = Math.min(canvas.width / width, canvas.height / height) * 0.9;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        let colorIndex = 0;
        ctx.beginPath();
        ctx.strokeStyle = data.colors[colorIndex]?.hex || "black";

        for (let i = 1; i < data.stitches.length; i++) {
          const [x1, y1, cmd1] = data.stitches[i - 1];
          const [x2, y2, cmd2] = data.stitches[i];

          if (cmd2 === 2) { // COLOR_CHANGE
            ctx.stroke();
            colorIndex++;
            ctx.beginPath();
            ctx.strokeStyle = data.colors[colorIndex]?.hex || "black";
            continue;
          }

          ctx.moveTo((x1 - minX) * scale + 20, (y1 - minY) * scale + 20);
          ctx.lineTo((x2 - minX) * scale + 20, (y2 - minY) * scale + 20);
        }
        ctx.stroke();

        setStatus("‚úÖ Sucesso: bordado carregado!", "ok");

        infoDiv.innerHTML = `
          <h2>Informa√ß√µes do Bordado</h2>
          <p><b>Largura:</b> ${(data.width_mm / 10).toFixed(2)} cm</p>
          <p><b>Altura:</b> ${(data.height_mm / 10).toFixed(2)} cm</p>
          <p><b>N√∫mero de cores:</b> ${data.num_colors}</p>
          <p><b>Total de pontos:</b> ${data.num_stitches}</p>
          <h3>Cores:</h3>
          <ul>
            ${data.colors.map(c => `<li><span style="color:${c.hex}">‚¨§</span> ${c.name || "Cor"} (${c.hex})</li>`).join("")}
          </ul>
        `;
      } catch (err) {
        setStatus("‚ùå Erro geral: " + err, "error");
      }
    });
  </script>
</body>
</html>